<!DOCTYPE html>
<html lang="en">
<style>
    .body {
        background-color: #8AC007;
        border-radius: 10px;
        font-size: 15px;
        width: fit-content;
        color: white;
        font-family: Arial, Helvetica, sans-serif;
        padding: 10px;
    }

    .title {
        background-color: white;
        color: grey;
        font-size: 20px;
        font-family: Arial, Helvetica, sans-serif;
        padding: 5px;
    }
    .frame{
        
    }
</style>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cat Coding</title>


</head>

<body>
    <div id='container'>
        WHY ONLY HAVE FEW ANALYSISED , WHY STOPED
        <br id='container_end'></div>
    </div>
</body>
<script>

    'use strict';

    function postMsg(line, character) {
        const vscode = acquireVsCodeApi();
        vscode.postMessage({ line, character });
    }

    // Handle the message inside the webview


    window.addEventListener('message', event => {
        const message = event.data; // The JSON data our extension sent
        initial(message); // initialize data, rebuild code structure
    });

    /** 
     * functions for handle content in code block
     */
    var codeAnalysis = {
        /**
         * Split source to sub code block's source text
         * @function
         * @prarm {string} t source text from editor.
         * @retruns {object} sub code block's source text
         */
        block: function (t) {
            var _result = []; // result for CodeBlock array;
            let _t = t;

            // get list from reg.list
            let _regResult = reg.list(t, reg.regBetween('function', '{'));

            if (_regResult.length == 0) { throw ('_regResult is empty') };

            //handle list from reg.list
            for (let i = 0; i < _regResult.length; i++) {
                const element = _regResult[i];
                let _block = new CodeBlock(element[0], element.index, element, 'function');

                // link previous and next in block;
                if (i > 0) {
                    _block.previous = _result[i - 1];
                    _result[i - 1].next = _block;
                }
                _result.push(_block);
            }
            return _result[0];



        },
        /**
        * for seperate lines in vsc source. will get lines index array.
        * @param {string} t source text.
        * @returns {array} array for line objects.
        */
        line: function (t) {

        },

        anno: function (b) { },
        prop: function (b) { },
    }

    /**
     * Initial whole process
     * @function
     */
    function initial(content) {
        ASThandler(content);


        let container = document.getElementById('container');
        let container_ed = document.getElementById('container_end');

        // analysis contetn text and generate a content node tree;
        let sourceTree = contentStructure(content);

        //render node tree;
        // diagramRender(sourceTree, container);

        //when click on each element rendered on container, move cursor to where it is.
        eventHandler.do_vscCursor();
        // event include these:
        // 1: mouse :   cilck on diagram move cursor to the position
        // 2: zoom:     select and zoom in.
        // 3: modify:   change diagram content (add/delete/modify)update to vscode
        // 4: gesture:  move or drag update to vscode

    }


    /**
     * generate code block instances
     * @function
     * @param {string} content text capture from editor. 
     * @returns {CodeBlock} root CodeBlock instance.
     */
    function contentStructure(content) {
        let _result = content; // : string

        _result = codeAnalysis.block(_result); // return root block


        return _result;// root block include all block instances
    }



    /**
     * Create codeBlock instance for block structure, which contain line, charater, 
     * content, etc...
     * @class
     * @param {string} name function name;
     * @param {number} index index in vsc
     * @param {string} source source content.
     * @param {CodeBlock} next next CodeBlock node
     * @param {CodeBlock} previous previous CodeBlock node
     */
    function CodeBlock(name, index, source, type) {
        this.type = null;
        this.name = name;
        // this.line = line;
        // this.character = character;
        this.source = source;
        this.previous = null;
        this.next = null;

    }


    /**
     * Render from root codeBlock
     * @param {CodeBlock} nodeTree root codeBlock, also can be where want to generate.
     * @param {string} container here is a test;
     */
    function diagramRender(nodeTree, container) {
        let _nodeT = nodeTree;
        let _node = _nodeT; // pointer node from root codeBlock;
        if (nodeTree == null) {
            throw ('code structure is empty');
            return;
        };

        // PositionGenerator(nodeTree); // add position prop to block

        /** 
         * Render source
         * @param {string} content innerText of render element.
        */
        function renderElementGenerator(text) {
            var _result = document.createElement('div');
            _result.innerText = text;
            container.appendChild(_result);
        }

        //render from root, traverse each next;
        while (_node != null) {
            renderElementGenerator(_node.name);
            _node = _node.next; // pointer move to next one.
        }


    }


    var eventHandler = {
        do_vscCursor: function (param) { }
    };
    /* ||||||||||||||||||||||||||||||||||| Text handle functions||||||||||||||||||||||||||||||||||||*/
    /**
     * Text handler
     * @function
     * RegExp extension
     */
    var reg = {
        /**
        * search regExp in whole string, will return a list for all information
        * @param {string} source source input text
        * @param {RegExp} k searching keyword.
        * @retrun {[]} list for all information in sourceText.['result-1','result-2',...]
        */
        list: function (source, k) {
            let _key = new RegExp(k, 'g');
            //Attention: Here must be 'g' as attr, otherwise only output first result;
            let _result = [];
            let _s = source;
            let _item = _key.exec(_s);
            let _check = 10;
            while (_item != null && _check > 0) {
                _check -= 1;
                // _result.push(_item);
                _result.push(_item);
                _item = _key.exec(_s);// Attention sequence with push.
            }
            return _result;
        },
        keyList: function (source, k) {
            let _fullList = this.list(source, k);
            let _result = { result: [], groups: [], index: [], input: [], length: [] };
            _fullList.forEach(element => {

                _result.result.push(element[0])
                _result.groups.push(element.groups);
                _result.index.push(element.index);
                _result.input.push(element.input);
                _result.length.push(element.length);
            });
            return _result;
        },

        /** get RegExp instance between Beginning and end keywords;
         * @param {string} beginning beginning keyword
         * @param {string} end end keyword
         * @returns {RegExp} retrun RegExp instance;
         */
        regBetween: function (beginning, end) {
            let _source = '(?<=' + beginning + ').*?(?=' + end + ')';
            return new RegExp(_source, 'g');
        }
    }
    /** content comparison function
     * 
     */
    var contentComparison = {


    }
    /** get line from block.
     */
    var lineHandler = {
        lineMarker: '\n',
        list: [],
        /** reset line marker pool. 
        * @returns return marker list.
        */
        refresh: function () {
            this.list = [];
            return this.list;
        },
        /** update line marker list pool
        * @param {number} beginning updating start index of source text.
        * @param {number} end updating end index in source text.
        * @return {[]} return lineHandler.list.
        */
        update: function (source, beginning = 0, end = null) {

            let _source = end != null ? source.slice(beginning, end) : source;

            let updateContent = reg.keyList(_source, this.lineMarker);

            // find location for beginning and end in list.
            let _range_st = index.divisionFind(this.list, beginning);
            let _range_ed = index.divisionFind(this.list, end);

            //update list
            this.list.splice(_range_st, _range_ed - _range_st, [...updateContent.index]);

            return this.list;

        },
        get: function (indexCheck) {
            // each update will compare where updated, take out updating lines marker do insert/delete in list;
            // if index less than last item in list, then check where is the index, return its index in list.
            // else: generate following index list, to indexCheck.

            let _lastIndexInList; // get last index in list.
            // list is empty last index is 0 , else is last item in list.
            if (this.list.length == 0) {
                _lastIndexInList = 0;
            } else {
                _lastIndexInList = this.list[this.list.length - 1];
            }

            // indexCheck already had in list then return it.
            // else push line markers from last one to indexCheck.
            if (_lastIndexInList >= indexCheck) {

            }

        },

    };

    // extension of get line function. provide functions of how to locate where index 
    var indexLocate = {
        /** function of division find.
        @param {[]} list where this function find from 
        @param {number} key finding key.
        @returns {number} index where the key is or where it should be.
        */
        divisionFind: function (list, key) {
            if (list.length == 0) { return; }

            let _l = list;

            // if length <= 3 use beginningFind function.
            if (_l.length <= 3) {
                return this.beginningFind(list, key);
            }

            let _OverRange = (key > _l[_l.length - 1] && _l.length) || (key < _l[0] && 0);
            if (_OverRange !== false) { return _OverRange; }


            // filt even number;
            // if (_l.length % 2 == 0) {
            //     // r = l.last < key -> _l.length or l.last == key -> l.length
            //     let _r = _l[_l.length - 1] < key && _l.length || _l[_l.length] == key && _l.length;
            //     console.log(_r);
            //     if (_r) { return _r; };
            //     _l.pop();
            // }


            let _left = 0; // left pointer 
            let _over = 12;
            let _right = _l.length - 1; // right pointer
            let _indexPointer; // mid index 


            do {
                _indexPointer = ((_right - _left) % 2 == 0) ? ((_right - _left) / 2 + _left) : ((_right - _left - 1) / 2 + _left);
                _over -= 1;
                if (_over == 0) {
                    throw ('over while');
                }

                // if mid is result then just return mid.
                if (_l[_indexPointer] == key) {
                    return _indexPointer;
                }

                // mid > finding key, result on the left
                if (key < _l[_indexPointer]) {

                    _right = _indexPointer;
                } else if (key > _l[_indexPointer]) {
                    _left = _indexPointer;
                }
                // two index ?  get smaller one, cause it will repalce the larger one in result.



            } while (_right - _left > 2);

            let _result;
            if (key == _l[_left] | key == _l[_right] | key == _l[_indexPointer]) {

                _result = key == _l[_left] ? _left : key == _l[_right] ? _right : _indexPointer;
                return _result
            }

            _result = key < _l[_indexPointer] ? _indexPointer : _right;

            return _result;

        },
        beginningFind: function (list, key) {
            let _resultIndex = 0;
            if (this.list.length == 0) { return 0; }

            while (_resultIndex < list.length) {
                if (element == key) {
                    return _resultIndex;
                }

                // element same as key | element < result < element[i+1];
                if ((list[_resultIndex] < key && list[_resultIndex + 1] > key)) {
                    return _resultIndex + 1;
                }

                // if 2th of last still not match, means result should in the last of list. return last index +1/
                if (_resultIndex == list.length - 2) { return list.length }

                _resultIndex += 1;
            }
        }

    }
    /*11111111111111111111111111111111111111111111111111111111111111111*/

    //                  AST GENERATOR

    /*11111111111111111111111111111111111111111111111111111111111111111*/
    /**
     *  AST handler Main function
     */
    function ASThandler(input) {
        let _result = AST.tokenize(input);

        _result = AST.onionize(_result);

        let _all = _result.getBodyElements();

        let a = new diagram(document.getElementById('container'));
        a.update(_result);
        console.log(_all);

        return _result;

    }

    function toArray(input) {
        let result = input;
        if (!result) {
            return false;
        }
        result = Array.isArray(result) ? result : [result];
        return result;
    }


    /**
     * AST type register for instance types
     */
    class AST_Type_Register {
        constructor(
            prop = {
                typeIndicator: 'unknown',
                name: 'unknown',
                start: '',
                end: '\n',
            }
        ) {
            this.typeIndicator = prop.typeIndicator;
            this.name = prop.name;
            this.end = toArray(prop.end) || [';', '\n'];
            this.start = prop.start;
        }
        endCheck(input) {
            if (Array.isArray(this.end)) {
                return this.end.includes(input);
            }

            return input == this.end;
        }
        startCheck(input) {
            if (!this.start) { return; }
            if (Array.isArray(this.start)) {
                let _r = this.start.includes(input);
                return (_r);
            }

            return (input == this.start);
        }
        analysisId(content) {
            return content[1];
        }

        renderAllNode(unit, parent) {

        }
    }

    /**
     * for generate AST unit, can be lines/ block
     */
    var typeMarker = {
        startCheck: function (input) {
            let _in = input;
            let _result = false;
            for (const i in this) {
                if (this.hasOwnProperty(i)) {
                    const element = this[i];
                    if (element instanceof AST_Type_Register) {
                        if (element.startCheck(_in) == true) {
                            _result = element;
                            break;
                        }
                    }

                }

            }

            return _result;
        },
        function: new AST_Type_Register({
            typeIndicator: 'function_Indicator',
            name: 'function',
            start: 'function',
            end: '}'
        }),

        class: new AST_Type_Register({
            typeIndicator: 'class_Indicator',
            name: 'class',
            start: 'class',
            end: '}'
        }),
        variable: new AST_Type_Register({
            typeIndicator: 'variable_Indicator',
            name: 'variable',
            start: ['var', 'let', 'const'],
            end: [';', '\n']
        }),
        expression: new AST_Type_Register({
            typeIndicator: 'command',
            name: 'command',
            start: false,
            end: ''
        })
    };

    var commandMarker = {

    }
    class AST_Unit {
        constructor() {
            this.body_content = [];
            this.body_units = [];
            this.body = [];
            this.type;

        }


        getBodyElements() {

            let _result = [];
            let _ASTStack = [];

            // this.body.map(i=>{
            //     if(typeof(i) == 'string'){
            //         _result.push(i);
            //     }else{
            //         _ASTStack.push(i.getBodyElements());
            //     }
            // });
            // _result.join(' ');
            // _ASTStack.join(' ');
            // return _result.concat(_ASTStack);

            for (let i = 0; i < this.body.length; i++) {

                let element = this.body[i];

                if (typeof (element) == 'string') {
                } else {
                    _result = _result.concat(element.getBodyElements());
                }
            }

            if (_result == false) { return this }
            return _result;
        }

        push(content) {
            this.body.push(content);
            if (typeof (content) == 'string') {
                this.body_content.push(content);
            } else if (content instanceof AST_Unit == true) {
                this.body_units.push(content);
            }

        };
        /**
         * analysis is for content analysis after whole body finish;
         */
        analysis() {

        }

        /** type check prototype function
         * @returns false | type
         */
        getType(content = null) {


            if (!content) { return typeMarker.expression }

            let _type = typeMarker.expression;

            for (let i in typeMarker) {
                let _e = typeMarker.startCheck(content);
                if (_e) {
                    _type = typeMarker[i]; // return type instance
                    break;
                }
            }
            return _type;
        }
        endCheck(input) {
            if (!this.type) {
                if (input == '\n' | ';') {
                    return true;
                }
            } else {
                return this.type.endCheck(input);
            }
        }
        getContentNode() {
            this.type.renderNode(this);
        }
        renderNode() {
            let frame = draw.div(null, 'frame');
            frame.appendChild(draw.div(this.type.name, 'title'));
            let _body = draw.div(null, 'body');
            for (let i = 0; i < this.body.length; i++) {

                if (typeof (this.body[i]) == 'string') {

                    _body.appendChild(draw.span(this.body[i]));

                } else if (typeof (this.body[i]) == 'AST_Unit') {
                    _body.appendChild(this.body[i].renderNode());
                }
            }
            frame.appendChild(_body);
            return frame;
        }
    }


    var AST = {
        keySymbol: ['{', '}', ';', '\n', '(', ')'],
        /** replace key symbol with space
        */
        tokenize: function (input) {
            let _result = input;
            let _symbol = this.keySymbol;

            for (let i = 0; i < _symbol.length; i++) {
                let element = _symbol[i];
                let _replace = new RegExp('\\' + element, 'gm');
                // attention here, need double \ to make it works.
                _result = _result.replace(_replace, ' ' + element + ' ');
            };
            _result = _result.split(' ');
            _result = _result.filter(i => i);
            return _result;
        },
        /**
         * make cuted string have array structure
         * @param {[]} input expect result from tokenize
         */
        onionize: function (input) {

            let _source = input;
            let _result = this.readSource(_source, true, false);
            // let _resultList = this.listAll(_regResult);

            return _result;
        },
        /**
         * Show full list
         * @param {object} source AST_unit
         */
        listAll: function (source) {
            return source.getBodyElements();
        },
        /**
         * structure analysis
         * @param {[]} s souce text splted by space
         * @param {string} start start marker
         * @param {string} end end marker 
         */
        readSource: function (s, start, end) {
            // for source have to have start and end for all. like {function...}
            if (!s) {
                return;
            }

            let _e = s.shift();

            let isStart = typeMarker.startCheck(_e);
            if (_e === true || isStart != false) {
                let _res = new AST_Unit();
                _res.type = isStart;
                _res.push(_e);
                while (1) {
                    _res.push(this.readSource(s, start, end));
                    if (_res.endCheck(s[0]) == true) {
                        break;
                    };

                    //TODO : COMMAND END HAVE PROBLEM NEED MORE END MARKER
                }
                _res.push(s.shift());
                _res.analysis();

                return _res;
            }

            else {
                return _e;
                // throw ('unexpected');
            }
        }
    }


    //-------------------------------------------------------
    //                  SHOW 
    //  SHOW FUNCTION INCLUDE COMPARISION THEN HANDLE SHOWING
    //  KIND OF LIKE REACT
    //-------------------------------------------------------
    class diagram {
        constructor(canv) {
            this.canv = canv;
            this.contentList = [];
        }
        update(list) {
            this.canv.appendChild(list.renderNode());

            // let _newList = list;
            // if (this.contentList == false) {
            //     _newList.forEach(
            //         i => {
            //             this.show(i);
            //         }
            //     )
            // }
        }

        /**
         * render on DOM
         * @param {AST_Unit} unit
         * @param {*} parent 
         */
        show(unit, parent = null) {
            if (!parent) {
                this.canv.appendChild(unit.renderNode());
            } else {
                parent.appendChild(unit.getContentNode());
            }
        };
        /**
         * 
         * @param {AST_Unit} rootUnit
         */
        showAll(rootUnit) {
            let _list = rootUnit;
            let pointer;

            rootUnit.renderNode();
        }
    }


    function ASTListComparison(oldList, newList) {

    }


    //=========================================

    //                DIV GENERATOR

    //========================================
    var draw = {
        div: function (content = null, className = 'title') {
            let _result = document.createElement('div');
            _result.className = className;
            if (content) { _result.innerHTML = content }
            return _result;
        },
        break: function () {
            let _result = document.createElement('p');
            return _result;
        },
        p: function (content) {
            let _result = document.createElement('p');
            _result.innerHTML = content;
            return _result;
        },
        span: function (content) {
            let _result = document.createElement('span');
            _result.innerText = content;
            return _result;
        }

    }

    initial(`function a {
var a = 12;   
function b() { asd}
function asd (){
    function a {}
}function c (){ }
var a = 13;
var asd asd = 111;}
 `);
</script>

</html>