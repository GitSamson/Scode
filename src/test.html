<!DOCTYPE html>
<html lang="en">
<style>

</style>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cat Coding</title>


</head>

<body>
    <div id='container'>

        <br id='container_end'></div>
    </div>
</body>
<script>
    "use strict";

    function postMsg(line, character) {
        const vscode = acquireVsCodeApi();
        vscode.postMessage({ line, character });
    }

    // Handle the message inside the webview


    window.addEventListener('message', event => {
        const message = event.data; // The JSON data our extension sent
        initial(message); // initialize data, rebuild code structure
    });

    /** 
     * functions for handle content in code block
     */
    var codeAnalysis = {
        /**
         * Split source to sub code block's source text
         * @function
         * @prarm {string} t source text from editor.
         * @retruns {object} sub code block's source text
         */
        block: function (t) {
            var _result = []; // result for CodeBlock array;


            let _t = t;

            // get list from reg.list
            let _regResult = reg.list(t, reg.regBetween('function', ''));

            if (_regResult.length == 0) { throw ('_regResult is empty') };

            //handle list from reg.list
            for (let i = 0; i < _regResult.length; i++) {
                const element = _regResult[i];
                let _block = new CodeBlock(element[0], element.index, element, 'function');

                // link previous and next in block;
                if (i > 0) {
                    _block.previous = _result[i - 1];
                    _result[i - 1].next = _block;
                }
                _result.push(_block);
            }
            return _result[0];



        },
        /**
        * for seperate lines in vsc source. will get lines index array.
        * @param {string} t source text.
        * @returns {array} array for line objects.
        */
        line: function (t) {

        },

        anno: function (b) { },
        prop: function (b) { },
    }

    /**
     * Initial whole process
     * @function
     */
    function initial(content) {
        console.log(indexLocate.divisionFind([1,2,3,4,5,6],8));
        let container = document.getElementById('container');
        let container_ed = document.getElementById('container_end');

        // analysis contetn text and generate a content node tree;
        let sourceTree = contentStructure(content);

        //render node tree;
        diagramRender(sourceTree, container);

        //when click on each element rendered on container, move cursor to where it is.
        eventHandler.do_vscCursor();
        // event include these:
        // 1: mouse :   cilck on diagram move cursor to the position
        // 2: zoom:     select and zoom in.
        // 3: modify:   change diagram content (add/delete/modify)update to vscode
        // 4: gesture:  move or drag update to vscode

    }


    /**
     * generate code block instances
     * @function
     * @param {string} content text capture from editor. 
     * @returns {CodeBlock} root CodeBlock instance.
     */
    function contentStructure(content) {
        let _result = content; // : string

        _result = codeAnalysis.block(_result); // return root block


        return _result;// root block include all block instances
    }



    /**
     * Create codeBlock instance for block structure, which contain line, charater, 
     * content, etc...
     * @class
     * @param {string} name function name;
     * @param {number} index index in vsc
     * @param {string} source source content.
     * @param {CodeBlock} next next CodeBlock node
     * @param {CodeBlock} previous previous CodeBlock node
     */
    function CodeBlock(name, index, source, type) {
        this.type = null;
        this.name = name;
        // this.line = line;
        // this.character = character;
        this.source = source;
        this.previous = null;
        this.next = null;

    }


    /**
     * Render from root codeBlock
     * @param {CodeBlock} nodeTree root codeBlock, also can be where want to generate.
     * @param {string} container here is a test;
     */
    function diagramRender(nodeTree, container) {
        let _nodeT = nodeTree;
        let _node = _nodeT; // pointer node from root codeBlock;
        if (nodeTree == null) {
            throw ('code structure is empty');
            return;
        };

        // PositionGenerator(nodeTree); // add position prop to block

        /** 
         * Render source
         * @param {string} content innerText of render element.
        */
        function renderElementGenerator(text) {
            var _result = document.createElement('div');
            _result.innerText = text;
            container.appendChild(_result);
        }

        //render from root, traverse each next;
        while (_node != null) {
            renderElementGenerator(_node.name);
            _node = _node.next; // pointer move to next one.
        }


    }


    var eventHandler = {
        do_vscCursor: function (param) { }
    };
    /* ||||||||||||||||||||||||||||||||||| Text handle functions||||||||||||||||||||||||||||||||||||*/
    /**
     * Text handler
     * @function
     * RegExp extension
     */
    var reg = {
        /**
        * search regExp in whole string, will return a list for all information
        * @param {string} source source input text
        * @param {RegExp} k searching keyword.
        * @retrun {[]} list for all information in sourceText.
        */
        list: function (source, k) {
            let _key = new RegExp(k, 'g');
            //Attention: Here must be 'g' as attr, otherwise only output first result;
            let _result = [];
            let _s = source;
            let _item = _key.exec(_s);
            let _check = 10;
            while (_item != null && _check>0) {
                _check-=1;
                // _result.push(_item);
                _result.push(_item);
                _item = _key.exec(_s);// Attention sequence with push.
            }
            return _result;
        },
        keyList: function (source, k) {
            let _fullList = this.list(source, k);
            let _result = { result: [], groups: [], index: [], input: [], length: [] };
            _fullList.forEach(element => {

                _result.result.push(element[0])
                _result.groups.push(element.groups);
                _result.index.push(element.index);
                _result.input.push(element.input);
                _result.length.push(element.length);
            });
            return _result;
        },

        /** get RegExp instance between Beginning and end keywords;
         * @param {string} beginning beginning keyword
         * @param {string} end end keyword
         * @returns {RegExp} retrun RegExp instance;
         */
        regBetween: function (beginning, end) {
            let _source = '(?<=' + beginning + ').*?(?=' + end + ')';
            return new RegExp(_source, 'g');
        }
    }

    /** get line from block.
     */
    var lineHandler = {
        list: [],
        /** reset line marker pool. 
        * @returns return marker list.
        */
        refresh: function () {
            this.list = [];
            return this.list;
        },
        /** update line marker list pool
        * @param {number} beginning updating start index in source text.
        * @param {number} end updating end index in source text.
        * @return {[]} return lineHandler.list.
        */
        update: function (beginning, end) {


        },
        get: function (indexCheck) {
            // each update will compare where updated, take out updating lines marker do insert/delete in list;
            // if index less than last item in list, then check where is the index, return its index in list.
            // else: generate following index list, to indexCheck.

            let _lastIndexInList; // get last index in list.
            // list is empty last index is 0 , else is last item in list.
            if (this.list.length == 0) {
                _lastIndexInList = 0;
            } else {
                _lastIndexInList = this.list[this.list.length - 1];
            }

            // indexCheck already had in list then return it.
            // else push line markers from last one to indexCheck.
            if (_lastIndexInList >= indexCheck) {

            }

        },

    };

    // extension of get line function. provide functions of how to locate where index 
    var indexLocate = {
        /** function of division find.
        @param {[]} list where this function find from 
        @param {number} key finding key.
        @returns {number} index where the key is or where it should be.
        */
        divisionFind: function (list, key) {
            if (list.length == 0) { return; }

            // if length <= 3 use beginningFind function.
            if (list.length <= 3) {
                return this.beginningFind(list,key);
            }

            let _indexPointer; // mid index 
            let _left = 0; // left pointer 
            let _over = 10;
            let _right  = list.length-1; // right pointer
            while( _right-_left >1  ){

                _over-= 1;
                if(_over == 0 ){
                    throw('over while');
                }
                _indexPointer = Math.floor((_right-_left) / 2 + _left);

                // if mid is result then just return mid.
                if(list[_indexPointer] == key){
                    return _indexPointer;
                }

                // mid > finding key, result on the left
                if(key< list[_indexPointer]){
                    
                    _right = _indexPointer;
                }else{
                    _left = _indexPointer;
                }
            };
            let _result ;
            // TODO : how to handle result ? it could be less or greater than left/right. or == left/right. 
            // the result should be in while. there should be a comparison loop, if yes return the result 
            // !!!!!!!!!!!! 

        },
        beginningFind: function (list, key) {
            let _resultIndex = 0;
            if(this.list.length == 0){return 0;}

            while (_resultIndex < list.length) {
                if (element == key) {
                    return _resultIndex;
                }

                // element same as key | element < result < element[i+1];
                if ((list[_resultIndex] < key && list[_resultIndex + 1] > key)) {
                    return _resultIndex + 1;
                }

                // if 2th of last still not match, means result should in the last of list. return last index +1/
                if (_resultIndex == list.length - 2) { return list.length }

                _resultIndex += 1;
            }
        }

    }

    initial(`
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.wangEditor = factory());
}(this, (function () { 'use strict';

/*
    poly-fill
*/

var polyfill = function () {

    // Object.assign
    if (typeof Object.assign != 'function') {
        Object.assign = function (target, varArgs) {
            // .length of function is 2
            if (target == null) {
                // TypeError if undefined or null
                throw new TypeError('Cannot convert undefined or null to object');
            }

            var to = Object(target);

            for (var index = 1; index < arguments.length; index++) {
                var nextSource = arguments[index];

                if (nextSource != null) {
                    // Skip over if undefined or null
                    for (var nextKey in nextSource) {
                        // Avoid bugs when hasOwnProperty is shadowed
                        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                            to[nextKey] = nextSource[nextKey];
                        }
                    }
                }
            }
            return to;
        };
    }

    // IE 中兼容 Element.prototype.matches
    if (!Element.prototype.matches) {
        Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function (s) {
            var matches = (this.document || this.ownerDocument).querySelectorAll(s),
                i = matches.length;
            while (--i >= 0 && matches.item(i) !== this) {}
            return i > -1;
        };
    }
};

/*
    DOM 操作 API
*/

// 根据 html 代码片段创建 dom 对象
function createElemByHTML(html) {
    var div = void 0;
    div = document.createElement('div');
    div.innerHTML = html;
    return div.children;
}

// 是否是 DOM List
function isDOMList(selector) {
    if (!selector) {
        return false;
    }
    if (selector instanceof HTMLCollection || selector instanceof NodeList) {
        return true;
    }
    return false;
}

// 封装 document.querySelectorAll
function querySelectorAll(selector) {
    var result = document.querySelectorAll(selector);
    if (isDOMList(result)) {
        return result;
    } else {
        return [result];
    }
}

// 记录所有的事件绑定
var eventList = [];

// 创建构造函数
function DomElement(selector) {
    if (!selector) {
        return;
    }

    // selector 本来就是 DomElement 对象，直接返回
    if (selector instanceof DomElement) {
        return selector;
    }

    this.selector = selector;
    var nodeType = selector.nodeType;

    // 根据 selector 得出的结果（如 DOM，DOM List）
    var selectorResult = [];
    if (nodeType === 9) {
        // document 节点
        selectorResult = [selector];
    } else if (nodeType === 1) {
        // 单个 DOM 节点
        selectorResult = [selector];
    } else if (isDOMList(selector) || selector instanceof Array) {
        // DOM List 或者数组
        selectorResult = selector;
    } else if (typeof selector === 'string') {
        // 字符串
        selector = selector.replace('/\n/mg', '').trim();
        if (selector.indexOf('<') === 0) {
            // 如 <div>
            selectorResult = createElemByHTML(selector);
        } else {
            // 如 #id .class
            selectorResult = querySelectorAll(selector);
        }
    }

    var length = selectorResult.length;
    if (!length) {
        // 空数组
        return this;
    }

    // 加入 DOM 节点
    var i = void 0;
    for (i = 0; i < length; i++) {
        this[i] = selectorResult[i];
    }
    this.length = length;
}

// 修改原型
DomElement.prototype = {
    constructor: DomElement,

    // 类数组，forEach
    forEach: function forEach(fn) {
        var i = void 0;
        for (i = 0; i < this.length; i++) {
            var elem = this[i];
            var result = fn.call(elem, elem, i);
            if (result === false) {
                break;
            }
        }
        return this;
    },

    // clone
    clone: function clone(deep) {
        var cloneList = [];
        this.forEach(function (elem) {
            cloneList.push(elem.cloneNode(!!deep));
        });
        return $(cloneList);
    },

    // 获取第几个元素
    get: function get(index) {
        var length = this.length;
        if (index >= length) {
            index = index % length;
        }
        return $(this[index]);
    },

    // 第一个
    first: function first() {
        return this.get(0);
    },

    // 最后一个
    last: function last() {
        var length = this.length;
        return this.get(length - 1);
    },

    // 绑定事件
    on: function on(type, selector, fn) {
        // selector 不为空，证明绑定事件要加代理
        if (!fn) {
            fn = selector;
            selector = null;
        }

        // type 是否有多个
        var types = [];
        types = type.split(/\s+/);

        return this.forEach(function (elem) {
            types.forEach(function (type) {
                if (!type) {
                    return;
                }

                // 记录下，方便后面解绑
                eventList.push({
                    elem: elem,
                    type: type,
                    fn: fn
                });

                if (!selector) {
                    // 无代理
                    elem.addEventListener(type, fn);
                    return;
                }

                // 有代理
                elem.addEventListener(type, function (e) {
                    var target = e.target;
                    if (target.matches(selector)) {
                        fn.call(target, e);
                    }
                });
            });
        });
    },

    // 取消事件绑定
    off: function off(type, fn) {
        return this.forEach(function (elem) {
            elem.removeEventListener(type, fn);
        });
    },

    // 获取/设置 属性
    attr: function attr(key, val) {
        if (val == null) {
            // 获取值
            return this[0].getAttribute(key);
        } else {
            // 设置值
            return this.forEach(function (elem) {
                elem.setAttribute(key, val);
            });
        }
    },

    // 添加 class
    addClass: function addClass(className) {
        if (!className) {
            return this;
        }
        return this.forEach(function (elem) {
            var arr = void 0;
            if (elem.className) {
                // 解析当前 className 转换为数组
                arr = elem.className.split(/\s/);
                arr = arr.filter(function (item) {
                    return !!item.trim();
                });
                // 添加 class
                if (arr.indexOf(className) < 0) {
                    arr.push(className);
                }
                // 修改 elem.class
                elem.className = arr.join(' ');
            } else {
                elem.className = className;
            }
        });
    },

    // 删除 class
    removeClass: function removeClass(className) {
        if (!className) {
            return this;
        }
        return this.forEach(function (elem) {
            var arr = void 0;
            if (elem.className) {
                // 解析当前 className 转换为数组
                arr = elem.className.split(/\s/);
                arr = arr.filter(function (item) {
                    item = item.trim();
                    // 删除 class
                    if (!item || item === className) {
                        return false;
                    }
                    return true;
                });
                // 修改 elem.class
                elem.className = arr.join(' ');
            }
        });
    },

    // 修改 css
    css: function css(key, val) {
        var currentStyle = key + ':' + val + ';';
        return this.forEach(function (elem) {
            var style = (elem.getAttribute('style') || '').trim();
            var styleArr = void 0,
                resultArr = [];
            if (style) {
                // 将 style 按照 ; 拆分为数组
                styleArr = style.split(';');
                styleArr.forEach(function (item) {
                    // 对每项样式，按照 : 拆分为 key 和 value
                    var arr = item.split(':').map(function (i) {
                        return i.trim();
                    });
                    if (arr.length === 2) {
                        resultArr.push(arr[0] + ':' + arr[1]);
                    }
                });
                // 替换或者新增
                resultArr = resultArr.map(function (item) {
                    if (item.indexOf(key) === 0) {
                        return currentStyle;
                    } else {
                        return item;
                    }
                });
                if (resultArr.indexOf(currentStyle) < 0) {
                    resultArr.push(currentStyle);
                }
                // 结果
                elem.setAttribute('style', resultArr.join('; '));
            } else {
                // style 无值
                elem.setAttribute('style', currentStyle);
            }
        });
    },

    // 显示
    show: function show() {
        return this.css('display', 'block');
    },

    // 隐藏
    hide: function hide() {
        return this.css('display', 'none');
    },

    // 获取子节点
    children: function children() {
        var elem = this[0];
        if (!elem) {
            return null;
        }

        return $(elem.children);
    },

    // 获取子节点（包括文本节点）
    childNodes: function childNodes() {
        var elem = this[0];
        if (!elem) {
            return null;
        }

        return $(elem.childNodes);
    },

    // 增加子节点
    append: function append($children) {
        return this.forEach(function (elem) {
            $children.forEach(function (child) {
                elem.appendChild(child);
            });
        });
    },

    // 移除当前节点
    remove: function remove() {
        return this.forEach(function (elem) {
            if (elem.remove) {
                elem.remove();
            } else {
                var parent = elem.parentElement;
                parent && parent.removeChild(elem);
            }
        });
    },

    // 是否包含某个子节点
    isContain: function isContain($child) {
        var elem = this[0];
        var child = $child[0];
        return elem.contains(child);
    },

    // 尺寸数据
    getSizeData: function getSizeData() {
        var elem = this[0];
        return elem.getBoundingClientRect(); // 可得到 bottom height left right top width 的数据
    },

    // 封装 nodeName
    getNodeName: function getNodeName() {
        var elem = this[0];
        return elem.nodeName;
    },

    // 从当前元素查找
    find: function find(selector) {
        var elem = this[0];
        return $(elem.querySelectorAll(selector));
    },

    // 获取当前元素的 text
    text: function text(val) {
        if (!val) {
            // 获取 text
            var elem = this[0];
            return elem.innerHTML.replace(/<.*?>/g, function () {
                return '';
            });
        } else {
            // 设置 text
            return this.forEach(function (elem) {
                elem.innerHTML = val;
            });
        }
    },

    // 获取 html
    html: function html(value) {
        var elem = this[0];
        if (value == null) {
            return elem.innerHTML;
        } else {
            elem.innerHTML = value;
            return this;
        }
    },

    // 获取 value
    val: function val() {
        var elem = this[0];
        return elem.value.trim();
    },

    // focus
    focus: function focus() {
        return this.forEach(function (elem) {
            elem.focus();
        });
    },

    // parent
    parent: function parent() {
        var elem = this[0];
        return $(elem.parentElement);
    },

    // parentUntil 找到符合 selector 的父节点
    parentUntil: function parentUntil(selector, _currentElem) {
        var results = document.querySelectorAll(selector);
        var length = results.length;
        if (!length) {
            // 传入的 selector 无效
            return null;
        }

        var elem = _currentElem || this[0];
        if (elem.nodeName === 'BODY') {
            return null;
        }

        var parent = elem.parentElement;
        var i = void 0;
        for (i = 0; i < length; i++) {
            if (parent === results[i]) {
                // 找到，并返回
                return $(parent);
            }
        }

        // 继续查找
        return this.parentUntil(selector, parent);
    },

    // 判断两个 elem 是否相等
    equal: function equal($elem) {
        if ($elem.nodeType === 1) {
            return this[0] === $elem;
        } else {
            return this[0] === $elem[0];
        }
    },

    // 将该元素插入到某个元素前面
    insertBefore: function insertBefore(selector) {
        var $referenceNode = $(selector);
        var referenceNode = $referenceNode[0];
        if (!referenceNode) {
            return this;
        }
        return this.forEach(function (elem) {
            var parent = referenceNode.parentNode;
            parent.insertBefore(elem, referenceNode);
        });
    },

    // 将该元素插入到某个元素后面
    insertAfter: function insertAfter(selector) {
        var $referenceNode = $(selector);
        var referenceNode = $referenceNode[0];
        if (!referenceNode) {
            return this;
        }
        return this.forEach(function (elem) {
            var parent = referenceNode.parentNode;
            if (parent.lastChild === referenceNode) {
                // 最后一个元素
                parent.appendChild(elem);
            } else {
                // 不是最后一个元素
                parent.insertBefore(elem, referenceNode.nextSibling);
            }
        });
    }
};

    
    `);
</script>

</html>